cmake_minimum_required(VERSION 3.19.2)

# ctp.cmake - detect local CTP (Thost) headers and libraries under the project's res/ directory
# This file will search for ThostFtdcMdApi.h and set CTP_INCLUDE_DIRS and CTP_LIBRARIES
# as CACHE variables if they are not provided by the user.

# Default search root (repo res directory)
if (NOT DEFINED CTP_SEARCH_ROOT)
	set(CTP_SEARCH_ROOT "${CMAKE_CURRENT_LIST_DIR}/../res")
endif()

message(STATUS "CTP: search root = ${CTP_SEARCH_ROOT}")

# Only auto-detect if user didn't explicitly set CTP_INCLUDE_DIRS
if(NOT DEFINED CTP_INCLUDE_DIRS OR CTP_INCLUDE_DIRS STREQUAL "")
	if(EXISTS "${CTP_SEARCH_ROOT}")
		file(GLOB_RECURSE _ctp_headers RELATIVE "${CTP_SEARCH_ROOT}" "${CTP_SEARCH_ROOT}/*ThostFtdcMdApi.h")
		if(_ctp_headers)
			# Prefer Windows x64-like paths when building on Windows
			set(_selected_header "")
			if(WIN32)
				foreach(_h IN LISTS _ctp_headers)
					string(TOLOWER "${_h}" _h_lower)
					if(_h_lower MATCHES "windows" AND (_h_lower MATCHES "64" OR _h_lower MATCHES "traderapi64"))
						set(_selected_header "${_h}")
						break()
					endif()
				endforeach()
			endif()
			if(NOT _selected_header)
				list(GET _ctp_headers 0 _selected_header)
			endif()

			# Build absolute path to selected header directory
			get_filename_component(_abs_header "${CTP_SEARCH_ROOT}/${_selected_header}" ABSOLUTE)
			get_filename_component(_inc_dir ${_abs_header} DIRECTORY)

			set(CTP_INCLUDE_DIRS "${_inc_dir}")
			message(STATUS "CTP: detected header dir = ${CTP_INCLUDE_DIRS}")
		else()
			message(STATUS "CTP: no ThostFtdcMdApi.h found under ${CTP_SEARCH_ROOT}")
		endif()
	else()
		message(STATUS "CTP: search root does not exist: ${CTP_SEARCH_ROOT}")
	endif()
else()
	message(STATUS "CTP: user-provided CTP_INCLUDE_DIRS = ${CTP_INCLUDE_DIRS}")
endif()

# Only auto-detect CTP_LIBRARIES if not set by user
if(NOT DEFINED CTP_LIBRARIES OR CTP_LIBRARIES STREQUAL "")
	if(EXISTS "${CTP_SEARCH_ROOT}")
		# Collect only platform-appropriate library file extensions to avoid
		# passing incompatible files (e.g. Linux .so) to the MSVC linker on Windows.
		if(WIN32)
			# On Windows, collect import libraries (.lib) for linking and DLLs for runtime copying
			file(GLOB_RECURSE _ctp_libs "${CTP_SEARCH_ROOT}/*.lib")
			file(GLOB_RECURSE _ctp_dlls "${CTP_SEARCH_ROOT}/*.dll")
			list(REMOVE_DUPLICATES _ctp_libs)
			list(REMOVE_DUPLICATES _ctp_dlls)

			# Determine target architecture: 8 => 64-bit, else 32-bit
			if (CMAKE_SIZEOF_VOID_P EQUAL 8)
				set(_wanted_arch "64")
			else()
				set(_wanted_arch "32")
			endif()

			# prefer files under detected include dir (if available)
			set(_libs_selected "")
			set(_dlls_selected "")
			if(DEFINED CTP_INCLUDE_DIRS AND NOT CTP_INCLUDE_DIRS STREQUAL "")
				file(REAL_PATH "${CTP_INCLUDE_DIRS}" _inc_real)
				foreach(_f IN LISTS _ctp_libs)
					file(REAL_PATH "${_f}" _f_real)
					string(FIND "${_f_real}" "${_inc_real}" _found)
					if(NOT _found EQUAL -1)
						list(APPEND _libs_selected "${_f}")
					endif()
				endforeach()
				foreach(_f IN LISTS _ctp_dlls)
					file(REAL_PATH "${_f}" _f_real)
					string(FIND "${_f_real}" "${_inc_real}" _found)
					if(NOT _found EQUAL -1)
						list(APPEND _dlls_selected "${_f}")
					endif()
				endforeach()
			endif()

			# helper: filter by simple name markers
			function(_filter_by_markers in_list out_var)
				set(_res "")
				foreach(_it IN LISTS ${in_list})
					string(TOLOWER "${_it}" _it_lc)
					if(_wanted_arch STREQUAL "64")
						if(_it_lc MATCHES "64" OR _it_lc MATCHES "x64" OR _it_lc MATCHES "amd64" OR _it_lc MATCHES "win64" OR _it_lc MATCHES "traderapi64")
							list(APPEND _res "${_it}")
						endif()
					else()
						if(_it_lc MATCHES "32" OR _it_lc MATCHES "x86" OR _it_lc MATCHES "win32" OR _it_lc MATCHES "ia32" OR _it_lc MATCHES "traderapi")
							list(APPEND _res "${_it}")
						endif()
					endif()
				endforeach()
				set(${out_var} "${_res}" PARENT_SCOPE)
			endfunction()

			if(NOT _libs_selected)
				_filter_by_markers(_ctp_libs _libs_selected)
			endif()
			if(NOT _dlls_selected)
				_filter_by_markers(_ctp_dlls _dlls_selected)
			endif()

			# fallback to original lists if selection empty
			if(NOT _libs_selected)
				set(_libs_selected "${_ctp_libs}")
			endif()
			if(NOT _dlls_selected)
				set(_dlls_selected "${_ctp_dlls}")
			endif()

			# Keep CTP_LIBRARIES containing only import .lib files for linking.
			# Build a list of runtime DLLs (same-dir matches + scanned dlls) and
			# export it as CTP_RUNTIME_DLLS so deployment copies them without
			# passing .dll paths to the linker.
			if(_libs_selected)
				set(CTP_LIBRARIES "${_libs_selected}")
				message(STATUS "CTP: detected import libraries: ${CTP_LIBRARIES}")

				# collect runtime dlls that sit next to selected .lib files
				set(_runtime_dlls "")
				foreach(_lib IN LISTS _libs_selected)
					get_filename_component(_lib_dir "${_lib}" DIRECTORY)
					get_filename_component(_lib_base "${_lib}" NAME_WE)
					set(_candidate_dll "${_lib_dir}/${_lib_base}.dll")
					if(EXISTS "${_candidate_dll}")
						list(APPEND _runtime_dlls "${_candidate_dll}")
					endif()
				endforeach()
				# include any dlls found by independent scan
				foreach(_dll IN LISTS _dlls_selected)
					list(FIND _runtime_dlls "${_dll}" _found_index)
					if(_found_index EQUAL -1)
						list(APPEND _runtime_dlls "${_dll}")
					endif()
				endforeach()
				if(_runtime_dlls)
					set(CTP_RUNTIME_DLLS "${_runtime_dlls}")
					message(STATUS "CTP: detected runtime DLLs: ${CTP_RUNTIME_DLLS}")
				else()
					message(STATUS "CTP: no DLLs found under ${CTP_SEARCH_ROOT}")
				endif()
			else()
				message(STATUS "CTP: no import libraries (.lib) found under ${CTP_SEARCH_ROOT}")
			endif()
		elseif(APPLE)
			file(GLOB_RECURSE _ctp_libs "${CTP_SEARCH_ROOT}/*.dylib" "${CTP_SEARCH_ROOT}/*.a")
			if(_ctp_libs)
				list(REMOVE_DUPLICATES _ctp_libs)
				set(CTP_LIBRARIES "${_ctp_libs}")
				message(STATUS "CTP: detected libraries: ${CTP_LIBRARIES}")
			else()
				message(STATUS "CTP: no libraries found under ${CTP_SEARCH_ROOT}")
			endif()
		else()
			# generic Unix/Linux
			file(GLOB_RECURSE _ctp_libs "${CTP_SEARCH_ROOT}/*.so" "${CTP_SEARCH_ROOT}/*.a")
			if(_ctp_libs)
				list(REMOVE_DUPLICATES _ctp_libs)
				set(CTP_LIBRARIES "${_ctp_libs}")
				message(STATUS "CTP: detected libraries: ${CTP_LIBRARIES}")
			else()
				message(STATUS "CTP: no libraries found under ${CTP_SEARCH_ROOT}")
			endif()
		endif()
	else()
		message(STATUS "CTP: search root does not exist: ${CTP_SEARCH_ROOT}")
	endif()
else()
	message(STATUS "CTP: user-provided CTP_LIBRARIES = ${CTP_LIBRARIES}")
endif()

# Export cache variables if we detected them (do not overwrite user-provided values)
if(DEFINED CTP_INCLUDE_DIRS AND NOT CTP_INCLUDE_DIRS STREQUAL "")
	set(CTP_INCLUDE_DIRS "${CTP_INCLUDE_DIRS}" CACHE PATH "CTP include directory (auto-detected)")
endif()
if(DEFINED CTP_LIBRARIES AND NOT CTP_LIBRARIES STREQUAL "")
	set(CTP_LIBRARIES "${CTP_LIBRARIES}" CACHE STRING "CTP library files (auto-detected)")
endif()

# Export runtime DLLs to cache so deploy logic can pick them up
if(DEFINED CTP_RUNTIME_DLLS AND NOT CTP_RUNTIME_DLLS STREQUAL "")
    set(CTP_RUNTIME_DLLS "${CTP_RUNTIME_DLLS}" CACHE STRING "CTP runtime DLLs (auto-detected)")
endif()

# Helpful note
message(STATUS "CTP: final CTP_INCLUDE_DIRS=${CTP_INCLUDE_DIRS}")
message(STATUS "CTP: final CTP_LIBRARIES=${CTP_LIBRARIES}")

# If user provided CTP_LIBRARIES or CTP_RUNTIME_DLLS, ensure they are filtered by target arch
if(WIN32)
	if (CMAKE_SIZEOF_VOID_P EQUAL 8)
		set(_wanted_arch "64")
	else()
		set(_wanted_arch "32")
	endif()

	function(_filter_list_by_arch input_var output_var)
		# read semicolon-separated list
		set(_items ${${input_var}})
		set(_filtered "")
		foreach(_it IN LISTS _items)
			string(TOLOWER "${_it}" _it_lc)
			set(_match FALSE)
			if(_wanted_arch STREQUAL "64")
				if(_it_lc MATCHES "64" OR _it_lc MATCHES "x64" OR _it_lc MATCHES "amd64" OR _it_lc MATCHES "win64" OR _it_lc MATCHES "traderapi64")
					set(_match TRUE)
				endif()
			else()
				if(_it_lc MATCHES "32" OR _it_lc MATCHES "x86" OR _it_lc MATCHES "win32" OR _it_lc MATCHES "ia32" OR _it_lc MATCHES "traderapi")
					set(_match TRUE)
				endif()
			endif()
			if(_match)
				list(APPEND _filtered "${_it}")
			endif()
		endforeach()
		if(NOT _filtered)
			# fallback to original list if no match found
			set(_filtered "${${input_var}}")
		endif()
		set(${output_var} "${_filtered}" PARENT_SCOPE)
	endfunction()

	if(DEFINED CTP_LIBRARIES AND NOT CTP_LIBRARIES STREQUAL "")
		_filter_list_by_arch(CTP_LIBRARIES _ctp_libs_user_filtered)
		set(CTP_LIBRARIES "${_ctp_libs_user_filtered}")
		# update cache too so downstream sees filtered value
		set(CTP_LIBRARIES "${CTP_LIBRARIES}" CACHE STRING "CTP library files (auto-detected/filtered)" FORCE)
		message(STATUS "CTP: filtered final CTP_LIBRARIES=${CTP_LIBRARIES}")
	endif()

	# If the user provided or we auto-detected runtime DLLs, filter them as well
	if(DEFINED CTP_RUNTIME_DLLS AND NOT CTP_RUNTIME_DLLS STREQUAL "")
		_filter_list_by_arch(CTP_RUNTIME_DLLS _ctp_dlls_user_filtered)
		set(CTP_RUNTIME_DLLS "${_ctp_dlls_user_filtered}")
		set(CTP_RUNTIME_DLLS "${CTP_RUNTIME_DLLS}" CACHE STRING "CTP runtime DLLs (auto-detected/filtered)" FORCE)
		message(STATUS "CTP: filtered final CTP_RUNTIME_DLLS=${CTP_RUNTIME_DLLS}")
	endif()
endif()

